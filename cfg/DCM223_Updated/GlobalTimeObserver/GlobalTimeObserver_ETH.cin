/*@!Encoding:1252*/

/* Include for Ethernet Global Time Observer
*
* Feature to monitor the global time for Ethernet.
* To monitor the global time of a channel, 
* the CIN file of the corresponding bus system must be included in a CAPL file via an "include".
* It may be necessary to adapt the packet type (cPTP_EthType) in this file.
*
* Version 1.0, (c) 2018 Vector Informatik GmbH, Department for Networks Distributed Systems
*/

includes
{

}

variables
{   
  const word cPTP_EthType = 0x88F7;

  const int MAXCHANNELS = 32;

  // message type identifier -> SYNC message
  //   first 4 bits (transport specific) => 802.1AS = 1
  //   second 4 bits (message type) => SYNC = 0
  const int eSYNC_PROTECTED = 0x10;      

  // message type identifier -> Follow up message
  //   first 4 bits (transport specific) => 802.1AS = 1
  //   second 4 bits (message type) => FOLLOW_UP = 8
  const int eFOLLOW_UP_PROTECTED = 0x18;

  const int mMinTimeDelay = 3; // Defines the minimum time in ms between a SYNC and a FUP message
  const int mMaxTimeDelay = 5; // Defines the maximum time in ms between a SYNC and a FUP message

  int64 mSyncLastTime[MAXCHANNELS];

  char mSysVarNameSpace[14] = "EthGlobalTime";

  mstimer maxDelayTimer[MAXCHANNELS];
  mstimer minDelayTimer[MAXCHANNELS];
}

on timer minDelayTimer(dword channel)
{
  long sysVal;
  char sysvarElementName[256];

  snprintf(sysvarElementName, elcount(sysvarElementName), "General[%d].MinTimeDelayFlag", channel );
  sysVal = sysGetVariableInt(mSysVarNameSpace, sysvarElementName);

  if ( sysVal != 0) 
  {
    // reset MinTimeDelayFlag 
    sysSetVariableInt(mSysVarNameSpace, sysvarElementName, 0);
  }
}

// sets the SYSVAR "MaxTimeDelayFlag" if the delay between SYNC and FUP exceeded
on timer maxDelayTimer(dword channel)
{
  char sysvarElementName[256];
  snprintf(sysvarElementName, elcount(sysvarElementName), "General[%d].MaxTimeDelayFlag", channel );
  sysSetVariableInt(mSysVarNameSpace, sysvarElementName, 1);
}

on ethernetPacket * 
{  
  OnEthernetPacket(this);
}

void OnEthernetPacket( ethernetPacket * packet ) 
{
  if (packet.type == cPTP_EthType) // check PTP type
  {
    if ( packet.byte(0) == eSYNC_PROTECTED) // sync message ( Type == 0x10)
    {
      setSyncVars(packet);
    }
    else if (packet.byte(0) == eFOLLOW_UP_PROTECTED) // FUP message ( Type == 0x18)
    {
      setFUPVars(packet);
    }
  }
}

// Function parse the SYNC message and set the corresponding SYSVAR values
void setSyncVars( ethernetPacket * syncPacket)
{  
  dword sequenceID;  
  dword controlField;
  int versionPTP;
  qword correctionField;

  char sysvarElementName[256];
  word channel;
  int i; 

  channel = syncPacket.msgChannel - 1 ;  

  if (channel < 0 || channel >= MAXCHANNELS )
  {
    channel = 0;
  }

  sysBeginVariableStructUpdate( sysvar::EthGlobalTime::Sync ); 

  versionPTP = syncPacket.byte(1) & 0x0F;   

  for( i = 0; i < 8; i++ )
  {
    correctionField |= ((qword)syncPacket.byte(8 + i)) << (8 *i);
  }

  sequenceID  = ((dword)syncPacket.byte(30)) << 8; 
  sequenceID |= ((dword)syncPacket.byte(31)); 

  controlField = ((dword)syncPacket.byte(32)); 

  snprintf(sysvarElementName, elcount(sysvarElementName), "Sync[%d].CorrectionField", channel );
  sysSetVariableLongLong (mSysVarNameSpace, sysvarElementName, correctionField);

  snprintf(sysvarElementName, elcount(sysvarElementName), "Sync[%d].VersionPTP", channel );
  sysSetVariableInt(mSysVarNameSpace, sysvarElementName, versionPTP);

  snprintf(sysvarElementName, elcount(sysvarElementName), "Sync[%d].SequenceID", channel );
  sysSetVariableInt(mSysVarNameSpace, sysvarElementName, sequenceID);

  snprintf(sysvarElementName, elcount(sysvarElementName), "Sync[%d].ControlField", channel );
  sysSetVariableInt(mSysVarNameSpace, sysvarElementName, controlField);  

  setTimer( minDelayTimer[channel], mMinTimeDelay );
  setTimer( maxDelayTimer[channel], mMaxTimeDelay );

  sysEndVariableStructUpdate( sysvar::EthGlobalTime::Sync );
}

// Function parse the Follow UP message and set the corresponding FUP values 
void setFUPVars( ethernetPacket * fupPacket)
{  
  qword seconds;
  qword nanoseconds;
  dword sequenceID;
  dword controlField;  
  qword correctionField;
  qword preciseOriginTimestamp;

  long sysVal;
  int versionPTP; 
  int i; 

  char sysvarElementName[256];
  word channel;
  channel = fupPacket.msgChannel - 1 ;  
  correctionField = 0;

  if (channel < 0 || channel >= MAXCHANNELS )
  {
    channel = 0;
  }

  sysBeginVariableStructUpdate( sysvar::EthGlobalTime::FUP );

  versionPTP = fupPacket.byte(1) & 0x0F;

  for( i = 0; i < 8; i++ )
  {
    correctionField |= ((qword)fupPacket.byte(8 + i)) << (8 *i);
  }

  sequenceID  = ((dword)fupPacket.byte(30)) << 8; 
  sequenceID |= ((dword)fupPacket.byte(31)); 

  controlField = ((dword)fupPacket.byte(32)); 

  // Fetch seconds from preciseOriginTimestamp of follow-up message
  seconds  = ((qword)fupPacket.byte(34)) << 40; 
  seconds |= ((qword)fupPacket.byte(35)) << 32; 
  seconds |= ((qword)fupPacket.byte(36)) << 24; 
  seconds |= ((qword)fupPacket.byte(37)) << 16; 
  seconds |= ((qword)fupPacket.byte(38)) <<  8; 
  seconds |= ((qword)fupPacket.byte(39)); 

  // Fetch nanoseconds from preciseOriginTimestamp of follow-up message
  nanoseconds   = ((qword)fupPacket.byte(40)) << 24; 
  nanoseconds  |= ((qword)fupPacket.byte(41)) << 16; 
  nanoseconds  |= ((qword)fupPacket.byte(42)) <<  8; 
  nanoseconds  |= ((qword)fupPacket.byte(43)); 
  
  preciseOriginTimestamp = (seconds * 1000000000LL) + nanoseconds;

  snprintf(sysvarElementName, elcount(sysvarElementName), "FUP[%d].CorrectionField", channel );
  sysSetVariableLongLong (mSysVarNameSpace, sysvarElementName, correctionField);

  snprintf(sysvarElementName, elcount(sysvarElementName), "FUP[%d].VersionPTP", channel );
  sysSetVariableInt(mSysVarNameSpace, sysvarElementName, versionPTP);

  snprintf(sysvarElementName, elcount(sysvarElementName), "FUP[%d].Seconds", channel );
  sysSetVariableLongLong(mSysVarNameSpace, sysvarElementName, seconds);

  snprintf(sysvarElementName, elcount(sysvarElementName), "FUP[%d].NanoSeconds", channel );
  sysSetVariableDWord(mSysVarNameSpace, sysvarElementName, nanoseconds);

  snprintf(sysvarElementName, elcount(sysvarElementName), "FUP[%d].SequenceID", channel );
  sysSetVariableInt(mSysVarNameSpace, sysvarElementName, sequenceID);

  snprintf(sysvarElementName, elcount(sysvarElementName), "FUP[%d].ControlField", channel );
  sysSetVariableInt(mSysVarNameSpace, sysvarElementName, controlField);

  // General part for FUP  
  if (mSyncLastTime[channel] != 0)
  {
    snprintf(sysvarElementName, elcount(sysvarElementName), "General[%d].Delta", channel );
    sysSetVariableInt(mSysVarNameSpace, sysvarElementName, preciseOriginTimestamp - mSyncLastTime[channel]);
  }
  
  // set the "new" last time stamp
  mSyncLastTime[channel] = preciseOriginTimestamp;
  
  snprintf(sysvarElementName, elcount(sysvarElementName), "General[%d].GlobalTime", channel );
  sysSetVariableFloat(mSysVarNameSpace, sysvarElementName, ((double) preciseOriginTimestamp) / 1000000000LL);

  if (isTimerActive( minDelayTimer[channel]))
  {
    cancelTimer( minDelayTimer[channel]);
    // If the timer is still active, the time interval between the SYNC and FUB message is too short -> MinTimeDelayFlag is set
    snprintf(sysvarElementName, elcount(sysvarElementName), "General[%d].MinTimeDelayFlag", channel );
    sysSetVariableInt(mSysVarNameSpace, sysvarElementName, 1);    
  }

  if (0 == isTimerActive( maxDelayTimer[channel])) // check if timer is inactive
  {
    snprintf(sysvarElementName, elcount(sysvarElementName), "General[%d].MaxTimeDelayFlag", channel );
    sysVal = sysGetVariableInt(mSysVarNameSpace, sysvarElementName);

    if ( sysVal != 0) 
    {
      // reset MaxTimeDelayFlag
      sysSetVariableInt(mSysVarNameSpace, sysvarElementName, 0);
    }
  }

  cancelTimer( maxDelayTimer[channel]);

  sysEndVariableStructUpdate( sysvar::EthGlobalTime::FUP );
}