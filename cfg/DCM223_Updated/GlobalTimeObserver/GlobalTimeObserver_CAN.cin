/*@!Encoding:1252*/

/* Include for CAN Global Time Observer
*
* Feature to monitor the global time for CAN.
* To monitor the global time of a channel, 
* the CIN file of the corresponding bus system must be included in a CAPL file via an "include".
* It may be necessary to adapt the message-id (cGlobalTime_CAN_ID) in this file.
*
* Version 1.0, (c) 2018 Vector Informatik GmbH, Department for Networks Distributed Systems
*/

includes
{

}

variables
{   
  // Global ID (Message ID) for the Global Time Message.
  // The ID must be adapted for the Global Time Message.
  // Since the id may be different on a different CAN channel,
  // further global time message IDs and the corresponding message handlers must be created.  
  const dword cGlobalTime_CAN_ID = 0x79; // CAN identifier of the Global Time message

  const int MAXCHANNELS = 32;

  const int eSYNC_PROTECTED = 0x20;
  const int eFOLLOW_UP_PROTECTED = 0x28;

  const int mMinTimeDelay = 38; // Defines the minimum time in ms between a SYNC and a FUP message
  const int mMaxTimeDelay = 42; // Defines the maximum time in ms between a SYNC and a FUP message

  int64 mSyncLastTime[MAXCHANNELS];
  int64 mSyncCounter [MAXCHANNELS];
  int64 mFUPCounter  [MAXCHANNELS];

  char mSysVarNameSpace[14] = "CANGlobalTime";

  mstimer maxDelayTimer[MAXCHANNELS];
  mstimer minDelayTimer[MAXCHANNELS];
}

on timer minDelayTimer(dword channel)
{
  long sysVal;
  char sysvarElementName[256];

  snprintf(sysvarElementName, elcount(sysvarElementName), "General[%d].MinTimeDelayFlag", channel );
  sysVal = sysGetVariableInt(mSysVarNameSpace, sysvarElementName);

  if ( sysVal != 0) 
  {
    // reset MinTimeDelayFlag 
    sysSetVariableInt(mSysVarNameSpace, sysvarElementName, 0);
  }
}

// sets the SYSVAR "MaxTimeDelayFlag" if the delay between SYNC and FUP exceeded
on timer maxDelayTimer(dword channel)
{
  char sysvarElementName[256];
  snprintf(sysvarElementName, elcount(sysvarElementName), "General[%d].MaxTimeDelayFlag", channel );
  sysSetVariableInt(mSysVarNameSpace, sysvarElementName, 1);
}

on message cGlobalTime_CAN_ID
{
  setVars (this);
}

void setVars(message * msg)
{
  if ( msg.byte(0) == eSYNC_PROTECTED) // sync message ( Type == 0x20)
  {
    setSyncVars(msg);
  }
  else if (msg.byte(0) == eFOLLOW_UP_PROTECTED) // FUP message ( Type == 0x28)
  {
    setFUPVars(msg);
  }
}  

// Function parse the SYNC message and set the corresponding SYSVAR values 
void setSyncVars( message * syncMsg)
{  
  word channel;
  char sysvarElementName[256];
  channel = syncMsg.msgChannel - 1 ;  

  if (channel < 0 || channel >= MAXCHANNELS )
  {
    channel = 0;
  }

  sysBeginVariableStructUpdate( sysvar::CANGlobalTime::Sync );

  snprintf(sysvarElementName, elcount(sysvarElementName), "Sync[%d].MessageType", channel );
  sysSetVariableInt(mSysVarNameSpace, sysvarElementName, syncMsg.byte(0)); 

  snprintf(sysvarElementName, elcount(sysvarElementName), "Sync[%d].CRC", channel );
  sysSetVariableInt(mSysVarNameSpace, sysvarElementName, syncMsg.byte(1)); 

  snprintf(sysvarElementName, elcount(sysvarElementName), "Sync[%d].TimeDomain", channel );
  sysSetVariableInt(mSysVarNameSpace, sysvarElementName, ((syncMsg.byte(2) & 0xF0) >> 4)); 

  snprintf(sysvarElementName, elcount(sysvarElementName), "Sync[%d].E2ESequenceCounter", channel );
  sysSetVariableInt(mSysVarNameSpace, sysvarElementName, syncMsg.byte(2) & 0x0F);

  snprintf(sysvarElementName, elcount(sysvarElementName), "Sync[%d].US0", channel );
  sysSetVariableInt(mSysVarNameSpace, sysvarElementName, syncMsg.byte(3));

  snprintf(sysvarElementName, elcount(sysvarElementName), "Sync[%d].Seconds", channel );
  sysSetVariableDWord(mSysVarNameSpace, sysvarElementName, swapDWord(syncMsg.dword(4)));

  mSyncCounter[channel] ++;
  snprintf(sysvarElementName, elcount(sysvarElementName), "General[%d].SyncCounter", channel );
  sysSetVariableInt(mSysVarNameSpace, sysvarElementName, mSyncCounter[channel]);  

  setTimer( minDelayTimer[channel], mMinTimeDelay );
  setTimer( maxDelayTimer[channel], mMaxTimeDelay );

  sysEndVariableStructUpdate( sysvar::CANGlobalTime::Sync );
}

// Function parse the Follow UP message and set the corresponding FUP values 
void setFUPVars( message * fupMsg)
{  
  long sysVal;
  word channel;
  qword seconds;
  qword nanoseconds;
  qword preciseOriginTimestamp;
  char sysvarElementName[256];
  channel = fupMsg.msgChannel - 1 ;

  if (channel < 0 || channel >= MAXCHANNELS )
  {
    channel = 0;
  }
 
  sysBeginVariableStructUpdate( sysvar::CANGlobalTime::FUP );
  
  seconds = @sysvarMember::CANGlobalTime::Sync[%CHANNEL%-1].Seconds;
  nanoseconds = swapDWord(fupMsg.dword(4));
  preciseOriginTimestamp = (seconds * 1000000000LL) + nanoseconds;

  snprintf(sysvarElementName, elcount(sysvarElementName), "FUP[%d].MessageType", channel );
  sysSetVariableInt(mSysVarNameSpace, sysvarElementName, fupMsg.byte(0)); 

  snprintf(sysvarElementName, elcount(sysvarElementName), "FUP[%d].CRC", channel );
  sysSetVariableInt(mSysVarNameSpace, sysvarElementName, fupMsg.byte(1)); 

  snprintf(sysvarElementName, elcount(sysvarElementName), "FUP[%d].TimeDomain", channel );
  sysSetVariableInt(mSysVarNameSpace, sysvarElementName, ((fupMsg.byte(2) & 0xF0) >> 4)); 

  snprintf(sysvarElementName, elcount(sysvarElementName), "FUP[%d].E2ESequenceCounter", channel );
  sysSetVariableInt(mSysVarNameSpace, sysvarElementName, fupMsg.byte(2) & 0x0F);

  snprintf(sysvarElementName, elcount(sysvarElementName), "FUP[%d].ReservedBits", channel );
  sysSetVariableInt(mSysVarNameSpace, sysvarElementName, ((fupMsg.byte(3) & 0xF8) >> 3));

  snprintf(sysvarElementName, elcount(sysvarElementName), "FUP[%d].SGW", channel );
  sysSetVariableInt(mSysVarNameSpace, sysvarElementName, ((fupMsg.byte(3) & 0x04) >> 2));

  snprintf(sysvarElementName, elcount(sysvarElementName), "FUP[%d].OVS", channel );
  sysSetVariableInt(mSysVarNameSpace, sysvarElementName, fupMsg.byte(3) & 0x03);

  snprintf(sysvarElementName, elcount(sysvarElementName), "FUP[%d].NanoSeconds", channel );
  sysSetVariableDWord(mSysVarNameSpace, sysvarElementName, nanoseconds);

  // General part for FUP  
  if (mSyncLastTime[channel] != 0)
  {
    snprintf(sysvarElementName, elcount(sysvarElementName), "General[%d].Delta", channel );
    sysSetVariableInt(mSysVarNameSpace, sysvarElementName, preciseOriginTimestamp - mSyncLastTime[channel]);
  }
  
  // set the "new" last time stamp
  mSyncLastTime[channel] = preciseOriginTimestamp;

  mFUPCounter[channel] ++;
  snprintf(sysvarElementName, elcount(sysvarElementName), "General[%d].FUPCounter", channel );
  sysSetVariableInt(mSysVarNameSpace, sysvarElementName, mFUPCounter[channel]);
  
  snprintf(sysvarElementName, elcount(sysvarElementName), "General[%d].GlobalTime", channel );
  sysSetVariableFloat(mSysVarNameSpace, sysvarElementName, ((double) preciseOriginTimestamp) / 1000000000LL);

  if (isTimerActive( minDelayTimer[channel]))
  {
    cancelTimer( minDelayTimer[channel]);
    // If the timer is still active, the time interval between the SYNC and FUB message is too short -> MinTimeDelayFlag is set
    snprintf(sysvarElementName, elcount(sysvarElementName), "General[%d].MinTimeDelayFlag", channel );
    sysSetVariableInt(mSysVarNameSpace, sysvarElementName, 1);    
  }

  if (0 == isTimerActive( maxDelayTimer[channel])) // check if timer is inactive
  {
    snprintf(sysvarElementName, elcount(sysvarElementName), "General[%d].MaxTimeDelayFlag", channel );
    sysVal = sysGetVariableInt(mSysVarNameSpace, sysvarElementName);

    if ( sysVal != 0) 
    {
      // reset MaxTimeDelayFlag
      sysSetVariableInt(mSysVarNameSpace, sysvarElementName, 0);
    }
  }

  cancelTimer( maxDelayTimer[channel]);

  sysEndVariableStructUpdate( sysvar::CANGlobalTime::FUP );
}