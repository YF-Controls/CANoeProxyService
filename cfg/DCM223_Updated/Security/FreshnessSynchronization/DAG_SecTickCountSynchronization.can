/*@!Encoding:1252*/

// Security Feature V2.10.6.0

//////////////////////////////////////////////////////////////
// DAG_SecTickCountSynchronization.can
//
// Testcase to read SecTickCounts from ECUs
// The following steps are necessary:
// 1. Local Authentication
// 2. SecOC_Local_TickCount_Read
// Both steps are repeated for each ECU with an assigned cdd.
// The maximum value of all read SecTickCounts is set to sysvar
// SeckTickSynchronization::SyncedMaxSecTickCount 
//
//////////////////////////////////////////////////////////////

includes
{
  
  #include "..\Authentication\LocalAuthentication_Helper.cin"
}

variables
{
  // date time info of ECU
  diagRequest Secured_System_Date_and_Time_Read Secured_System_Date_and_Time_Read;
  diagResponse Secured_System_Date_and_Time_Read Resp_Secured_System_Date_and_Time_Read;
  byte  binaryDateAndTime[15];
  dword binaryDateAndTimeLength = 15;
  byte  receivedDateAndTime[7];
  dword receivedDateAndTimeLength = 7;
  
  long currP2Timeout;
  
  int hasDateTime = 0;
}

void MainTest ()
{
  ReadSecTickCountForAllTargets();
  if( @sysvar::LocalAuthentication::CloseDiagChannelAfterAuth == 1 )
  {
    CloseDiagChannels(); // Close all open Diag Channels to the Diag Targets SEC_MGR-1499
  }
}

void CloseDiagChannels()
{
  int i = 0;
  char ecuQual[100]; 
  
  i = DiagTargetCount;
  while( i-- > 0) // for each target
  {
    diagGetTargetQualifier( i, ecuQual, elcount(ecuQual));
    diagCloseChannel(ecuQual); // Close all open Diag Channels to the Diag Targets SEC_MGR-1499
  }
}

testcase ReadSecTickCountForAllTargets()
{
  char ecuQual[100]; 
  int i;
  diagRequest SecOC_Local_TickCount_Read Req_ReadSecTickCount;
  diagResponse SecOC_Local_TickCount_Read Resp_ReadSecTickCount;
  
  byte ECU_SecTickCount[6];
  qword ECU_SecTickCountValue;
  qword maxSecTickCountValue = 0;
  long currP2Timeout;
  long ret;
  char msgBuff[100];
  char authRoleBuffer[30];
  
  byte dateTime[7];
  long copiedBytes;

  // panel clean up
  hasDateTime = 0;
  DeleteControlContent("SecTickCountSynchronization","OV_SecTickCount");  // panel update page ECU SecTickCount
  snprintf(msgBuff,100,"Sim Time: %5.3f s\n",TimeNowNS() / 1000000000.0); 
  putValueToControl("SecTickCountSynchronization","OV_SecTickCount",msgBuff);  // panel update page ECU SecTickCount
  
  maxSecTickCountValue = 0; // reset value
  
  // get all diag targets
  ReadDiagQualifier(); 
  testStepPass(" ","Available targets: %s",DiagTargetList);
     
  i = DiagTargetCount;
  while( i-- > 0) // for each target
  {
    TestStep("","");
    @sysvar::SeckTickSynchronization::LED_Sync_Result = 2;
    diagGetTargetQualifier( i, ecuQual, elcount(ecuQual));
    if( strncmp("VSM",ecuQual,3) == 0 ) 
    {
      // exclude
      continue;
    }
    diagSetTarget(ecuQual);
    currP2Timeout = diagGetP2Timeout();
    sysGetVariableDescriptionForValue(sysvar::DAG_Diagnostics::DiagnosticsRole, @sysvar::DAG_Diagnostics::DiagnosticsRole, authRoleBuffer, elcount(authRoleBuffer));
    TestStep("loop","ECU: %s",ecuQual);
    
    if (@SeckTickSynchronization::ExecuteAuthentication == 1)
    {
      testStep(" ","Authenticate for ECU %s currP2Timeout=%i role=%s",ecuQual,currP2Timeout,authRoleBuffer);
      Authenticate(ecuQual,@sysvar::DAG_Diagnostics::DiagnosticsRole);
    }
    
    if( ((@SeckTickSynchronization::ExecuteAuthentication == 1) && (@sysvar::LocalAuthentication::AuthResult == 1)) 
      || (@SeckTickSynchronization::ExecuteAuthentication == 0) )
    {
      // read ECU SecTickCount
      testStep(" ","Read ECU SecTickCount");
     
      diagSendRequest(Req_ReadSecTickCount);
      testWaitForDiagRequestSent(Req_ReadSecTickCount,1000);
      ret = testWaitForDiagResponse(Req_ReadSecTickCount,currP2Timeout);
      if( ret == 1) // response received
      {
        diagGetLastResponse(Req_ReadSecTickCount,Resp_ReadSecTickCount);
        diagGetParameterRaw(Resp_ReadSecTickCount,"TickCount",ECU_SecTickCount,elCount(ECU_SecTickCount));
        ConvertFreshnessArrayToQword(ECU_SecTickCount,ECU_SecTickCountValue);
        //write("%i %i %i %i %i %i",secTickCount[0],secTickCount[1],secTickCount[2],secTickCount[3],secTickCount[4],secTickCount[5]);
        testStep(" ","Target:%s LocalSecTickCount:0x%I64x",ecuQual,ECU_SecTickCountValue);
        snprintf(msgBuff,100,"%s:\t0x%02X %02X %02X %02X %02X\n",ecuQual,ECU_SecTickCount[1],ECU_SecTickCount[2],ECU_SecTickCount[3],ECU_SecTickCount[4],ECU_SecTickCount[5]);
        putValueToControl("SecTickCountSynchronization","OV_SecTickCount",msgBuff); // panel update page ECU SecTickCount
        
        if( @sysvar::SeckTickSynchronization::ReadSeckTickCountOnly != 1 ) // use secTickCount
        {
          // evaluate secTickCount
          testStep(" ","");
          if( ECU_SecTickCountValue > maxSecTickCountValue )
            maxSecTickCountValue = ECU_SecTickCountValue;
          testStep("Calculate max TickCount","MaxSecTickCount:0x%I64x LocalSecTickCount:0x%I64x",maxSecTickCountValue,ECU_SecTickCountValue);
          
          if( maxSecTickCountValue > 0 )
          {     
            @sysvar::SeckTickSynchronization::SyncedMaxSecTickCount = maxSecTickCountValue;
          }
          
          // consider sign for offset
          if( @sysvar::SeckTickSynchronization::SignTickCountOffset == 1 )
          {
            if (maxSecTickCountValue + @sysvar::SeckTickSynchronization::TickCountOffset > 0xFFFFFFFFFFLL)
            {
              @sysvar::SeckTickSynchronization::CalculatedSecTickCountWithOffset = 0xFFFFFFFFFFLL;
            }
            else
            {
              @sysvar::SeckTickSynchronization::CalculatedSecTickCountWithOffset = maxSecTickCountValue + @sysvar::SeckTickSynchronization::TickCountOffset;
            }
          }
          else
          {
            if (maxSecTickCountValue < @sysvar::SeckTickSynchronization::TickCountOffset)
            {
              @sysvar::SeckTickSynchronization::CalculatedSecTickCountWithOffset = 0;
            }
            else
            {
            @sysvar::SeckTickSynchronization::CalculatedSecTickCountWithOffset = maxSecTickCountValue - @sysvar::SeckTickSynchronization::TickCountOffset;
            }
          }

          // read ECU Date Time
          ReadECUDateTime(); // could read date time
                
          // deactivate Tester Present
          ControlTesterPresent(@sysvar::SeckTickSynchronization::CheckBox_DeactivateTesterPresent,ecuQual);
         
          @sysvar::SeckTickSynchronization::LED_Sync_Result = 1;
          @sysvar::SeckTickSynchronization::FinalResult = 1;
        }
      }
      else if( ret == 0) // p2 timeout occured
      {
        teststepWarning("","No response within P2 timeout.");
        @sysvar::SeckTickSynchronization::LED_Sync_Result = 0;
      }
      else
      {
        teststepFail("","Error ocurred returncode=%i",ret);
        @sysvar::SeckTickSynchronization::LED_Sync_Result = 0;
      }
    }
    else
    {
      @sysvar::SeckTickSynchronization::LED_Sync_Result = 0;
      testStepFail();
    }
  } //while
  
  // send one RTOffsetBroadcast for all, take the latest ECU DateTime Info
  if( hasDateTime == 1)
  {
    sysGetVariableData(sysvar::SeckTickSynchronization::ECU_DateTime, dateTime,copiedBytes);
    testWaitForTimeout(3000);
    teststep("Send RTOffsetBroadcast","DateTime: %d %d %d %d %d %d %d",dateTime[0],dateTime[1],dateTime[2],dateTime[3],dateTime[4],dateTime[5],dateTime[6]);
    @sysvar::SeckTickSynchronization::TriggerRTOffsetBroadcast = 1;
  }
  else
  {
    teststepfail("Send RTOffsetBroadcast","No ECU DateTime Info available.");
  }
}

int ControlTesterPresent(int enable, char ecu[])
{
  if( enable == 1 )
  {
    return diagStopTesterPresent(ecu);
  }
  else
  {
    return diagStartTesterPresent(ecu);
  }
          
}


int ReadECUDateTime()
{
  int ret;
  char qualifier[100]; 
  dword bufferLen = 100;
  
  diagGetCurrentEcu ( qualifier,  bufferLen);
  teststep("","");
  teststep("ReadECUDateTime","Read Date Time of ECU %s",qualifier);
  Secured_System_Date_and_Time_Read.SendRequest();
  ret = testWaitForDiagResponse(Secured_System_Date_and_Time_Read,currP2Timeout);
  if( ret == 1) // response received
  {
    diagGetLastResponse(Secured_System_Date_and_Time_Read,Resp_Secured_System_Date_and_Time_Read);
    Resp_Secured_System_Date_and_Time_Read.GetParameterRaw("Secured_System_Date_and_Time", binaryDateAndTime, binaryDateAndTimeLength);
    ConvertGTCTimeToBinaryTime(binaryDateAndTime, binaryDateAndTimeLength, receivedDateAndTime, receivedDateAndTimeLength);
    sysSetVariableData(sysvar::SeckTickSynchronization::ECU_DateTime,receivedDateAndTime,receivedDateAndTimeLength);
    teststep("","Received date time: %d %d %d %d %d %d %d",receivedDateAndTime[0],receivedDateAndTime[1],receivedDateAndTime[2],receivedDateAndTime[3],receivedDateAndTime[4],receivedDateAndTime[5],receivedDateAndTime[6]);
    hasDateTime = 1;
    return 1;
  }
  else if( ret == 0) // p2 timeout occured
  {
    teststepWarning("","No response within P2 timeout.");
    @sysvar::SeckTickSynchronization::LED_Sync_Result = 0;
    return -1;
  }
  else
  {
    teststepFail("","Error ocurred returncode=%i",ret);
    @sysvar::SeckTickSynchronization::LED_Sync_Result = 0;
    return 0;
  }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////
int ConvertFreshnessArrayToQword(byte array[], qword& freshness)
{
  int offset = 1;
  if( elCount(array) < 5 + offset )
    return -1;
  
  freshness = array[4 + offset] + 
              ((qword)array[3+ offset] << 8) + 
              ((qword)array[2+ offset] << 16) + 
              ((qword)array[1+ offset] << 24) + 
              ((qword)array[0+ offset] << 32);
  
  return 0;
}

/// \brief Converts time from the GTC time format to a binary time format
///
/// The GTC time without milliseconds is expected. Hence length 15 is expected.
/// The binary time will have length 7 and the format {year, year, month, day, hours, minutes, seconds}
/// Example: 32 30 31 37 30 31 31 38 32 33 30 30 31 36 5a -> 20170118230016Z -> {20, 17, 1, 18, 23, 00, 16}
/// Return value: -1 -> error occurred, 0 -> no error
long ConvertGTCTimeToBinaryTime(byte gtcTime[], dword gtcTimeLength, byte binaryTime[], dword& binaryTimeLength)
{
  int i, j;
  // expected format: yyyy mm dd hh mm ss Z
  if (gtcTimeLength != 15)
  {
    return -1;
  }

  // the binary time will have length 7
  if (elcount(binaryTime) < 7)
  {
    return -1;
  }
  binaryTimeLength = 7;

  i = 0;
  j = 0;
  while (i < 7 && j < 15)
  {
    binaryTime[i] = (gtcTime[j] - 0x30) * 10 + (gtcTime[j+1] - 0x30);
    i = i + 1;
    j = j + 2;
  }

  return 0;  
}

/// \brief Converts time from the GTC time format to a binary time format
///
/// The binary time with length 7 and the format {year, year, month, day, hours, minutes, seconds} is expected
/// The GTC time without milliseconds will be assumed. Hence length will be 15.
/// Example: {20, 17, 1, 18, 23, 00, 16} -> 20170118230016Z -> 32 30 31 37 30 31 31 38 32 33 30 30 31 36 5a
/// Return value: -1 -> error occurred, 0 -> no error
dword ConvertBinaryTimeToGTCTime(byte binaryTime[], dword binaryTimeLength, byte gtcTime[], dword& gtcTimeLength)
{
  int i, j;

  // expected binary time format
  if (binaryTimeLength != 7) return -1;
  binaryTimeLength = 7;
  
  // the GTC time will have length 15 (yyyy mm dd hh mm ss Z)
  if (elcount(gtcTime) < 15) return -1;
  gtcTimeLength = 15;  

  i = 0;
  j = 0;
  while (i < 15 && j < 7)
  {    
    gtcTime[i] = (binaryTime[j] / 10) + 0x30;
    gtcTime[i + 1] = (binaryTime[j] % 10) + 0x30;

    i = i + 2;
    j = j + 1;
  }

  return 0;  
}

dword ConvertCharArrayToByteArray(char charArray[], dword charArrayLength, byte byteArray[], dword byteArrayLength)
{
  int i;
  byte tmp;
  if(charArrayLength < (3 * byteArrayLength) - 1)
  {
    write("Failed with lens: %d, %d", charArrayLength, byteArrayLength);
    return -1;
  }
  for(i = 0; i < byteArrayLength; i++)
  {
    byteArray[i] = ConvertToByte(charArray[i * 3], charArray[(i * 3) + 1]);
  }
  return 1;
}

byte ConvertToByte(char char1, char char2)
{
  byte tmp;
  if(char1 <= '9')
  {
    tmp = (char1 - '0') << 4;
  }
  else
  {
    tmp = (char1 - 'A' + 10) << 4;
  }
  if(char2 <= '9')
  {
    tmp = tmp + (char2 - '0');
  }
  else
  {
    tmp = tmp + (char2 - 'A' + 10);
  }
  return tmp;
}
